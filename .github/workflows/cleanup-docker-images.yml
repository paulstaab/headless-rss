name: Cleanup Docker Images

on:
  schedule:
    # Run weekly on Sundays at 02:00 UTC
    - cron: '0 2 * * 0'
  workflow_dispatch: # Allow manual trigger

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Cleanup old container images
        run: |
          # Get package versions - try different package name formats
          OWNER="${{ github.repository_owner }}"
          REPO="${{ github.event.repository.name }}"
          
          # Calculate 30 days ago timestamp
          CUTOFF_DATE=$(date -d '30 days ago' -u +%Y-%m-%dT%H:%M:%SZ)
          echo "Deleting untagged container images older than: $CUTOFF_DATE"
          
          # First, let's check what packages exist to debug the issue
          echo "Checking available packages for debugging..."
          
          # Try both user and organization endpoints
          echo "Trying user packages endpoint..."
          USER_PACKAGES_RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/users/$OWNER/packages?package_type=container")
          echo "User container packages:"
          echo "$USER_PACKAGES_RESPONSE" | jq -r '.[].name' 2>/dev/null || echo "No user packages found or failed to parse"
          
          echo "Trying organization packages endpoint..."
          ORG_PACKAGES_RESPONSE=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/orgs/$OWNER/packages?package_type=container")
          echo "Organization container packages:"
          echo "$ORG_PACKAGES_RESPONSE" | jq -r '.[].name' 2>/dev/null || echo "No org packages found or failed to parse"
          
          # Try different package name possibilities and API endpoints
          PACKAGE_NAMES=("headless-rss" "$REPO" "$OWNER/$REPO")
          API_ENDPOINTS=("users" "orgs")
          VERSIONS=""
          SUCCESSFUL_PACKAGE_NAME=""
          SUCCESSFUL_ENDPOINT=""
          
          for ENDPOINT in "${API_ENDPOINTS[@]}"; do
            for PACKAGE_NAME in "${PACKAGE_NAMES[@]}"; do
              echo "Trying package name: $PACKAGE_NAME on endpoint: $ENDPOINT"
              
              # Try the API call and capture both response and HTTP status
              API_RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/$ENDPOINT/$OWNER/packages/container/$PACKAGE_NAME/versions")
              
              # Extract HTTP status and response body
              HTTP_STATUS=$(echo "$API_RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
              RESPONSE_BODY=$(echo "$API_RESPONSE" | sed '/HTTP_STATUS:/d')
              
              echo "API call status for $PACKAGE_NAME on $ENDPOINT: $HTTP_STATUS"
              
              if [ "$HTTP_STATUS" = "200" ]; then
                echo "Successfully found package: $PACKAGE_NAME on endpoint: $ENDPOINT"
                SUCCESSFUL_PACKAGE_NAME="$PACKAGE_NAME"
                SUCCESSFUL_ENDPOINT="$ENDPOINT"
                
                # Parse versions from successful response
                VERSIONS=$(echo "$RESPONSE_BODY" | jq -r '.[] | select(.metadata.container.tags | length == 0) | select(.created_at < "'$CUTOFF_DATE'") | .id' 2>/dev/null)
                
                # Show debug information
                TOTAL_VERSIONS=$(echo "$RESPONSE_BODY" | jq '. | length' 2>/dev/null || echo "0")
                UNTAGGED_VERSIONS=$(echo "$RESPONSE_BODY" | jq '[.[] | select(.metadata.container.tags | length == 0)] | length' 2>/dev/null || echo "0")
                OLD_UNTAGGED=$(echo "$RESPONSE_BODY" | jq '[.[] | select(.metadata.container.tags | length == 0) | select(.created_at < "'$CUTOFF_DATE'")] | length' 2>/dev/null || echo "0")
                
                echo "Total versions found: $TOTAL_VERSIONS"
                echo "Untagged versions: $UNTAGGED_VERSIONS"
                echo "Old untagged versions: $OLD_UNTAGGED"
                
                break 2  # Break out of both loops
              elif [ "$HTTP_STATUS" = "404" ]; then
                echo "Package $PACKAGE_NAME not found on $ENDPOINT (404)"
              else
                echo "API call failed for $PACKAGE_NAME on $ENDPOINT with status $HTTP_STATUS"
                echo "Response: $RESPONSE_BODY"
              fi
            done
          done
          
          # Safety check - don't proceed if we got an empty response or error
          if [ -z "$VERSIONS" ] || [ -z "$SUCCESSFUL_PACKAGE_NAME" ] || [ -z "$SUCCESSFUL_ENDPOINT" ]; then
            echo "No old untagged versions found to delete."
            exit 0
          fi
          
          # Count versions to delete
          VERSION_COUNT=$(echo "$VERSIONS" | wc -l)
          echo "Found $VERSION_COUNT untagged versions to delete:"
          echo "$VERSIONS"
          
          # Safety check - don't delete more than 50 versions at once
          if [ "$VERSION_COUNT" -gt 50 ]; then
            echo "ERROR: Too many versions to delete ($VERSION_COUNT). This might indicate an issue."
            echo "Skipping deletion for safety. Please check manually."
            exit 1
          fi
          
          # Delete each old untagged version
          for VERSION_ID in $VERSIONS; do
            echo "Deleting version ID: $VERSION_ID from package: $SUCCESSFUL_PACKAGE_NAME (endpoint: $SUCCESSFUL_ENDPOINT)"
            DELETE_RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X DELETE \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/$SUCCESSFUL_ENDPOINT/$OWNER/packages/container/$SUCCESSFUL_PACKAGE_NAME/versions/$VERSION_ID")
            
            DELETE_HTTP_STATUS=$(echo "$DELETE_RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
            DELETE_RESPONSE_BODY=$(echo "$DELETE_RESPONSE" | sed '/HTTP_STATUS:/d')
            
            if [ "$DELETE_HTTP_STATUS" = "204" ]; then
              echo "Successfully deleted version $VERSION_ID"
            else
              echo "Failed to delete version $VERSION_ID (HTTP $DELETE_HTTP_STATUS)"
              if [ -n "$DELETE_RESPONSE_BODY" ]; then
                echo "Error response: $DELETE_RESPONSE_BODY"
              fi
            fi
          done
          
          echo "Cleanup completed successfully"